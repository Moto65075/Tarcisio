#include <esp_sleep.h> 
#include <Arduino.h>

// ==============================================================================
// ü§ñ FIRMWARE ROB√î I.A. (ESP32) - G4 COMO INDICADOR DE ALERTA
// ==============================================================================

// --- DEFINI√á√ïES DE PINAGEM ---
const int PINO_BOTAO_PTT = 0;   
const int PINO_LED_STATUS = 13; // LED G13: Rob√¥ Ligado/Ocioso
const int PINO_LED_ESPERA = 14;   // LED G14: Escuta Ativa
const int PINO_LED_ALERTA = 4;   // LED G4: Alerta (Wi-Fi/Bateria Baixa)

// --- M√ÅQUINA DE ESTADOS ---
enum RobotState {
  STATE_STANDBY,    
  STATE_IDLE,       // Ocioso (G13 ON)
  STATE_ESPERANDO_FALA, // Escuta Ativa (G13 ON, G14 ON)
  STATE_ALERTA      // NOVO ESTADO: Alerta (G13 ON, G4 PISCA)
};

RobotState currentState = STATE_IDLE; 

// --- VARI√ÅVEIS DE CONTROLE DE TEMPO ---
unsigned long tempoPressionado = 0;
unsigned long lastActivityTime = 0; 
unsigned long wakeUpTime = 0; 
unsigned long lastAlertToggle = 0; // Novo: Para fazer o LED de Alerta piscar
const long TEMPO_PISCADA_ALERTA = 500; // Pisca a cada 500ms
const long TEMPO_TOQUE_LONGO = 3000; 
const long TIMEOUT_STANDBY = 50000; 
const long GUARD_TIME = 3000; 
const int TEMPO_PISCADA_FEEDBACK = 150; 

// Vari√°veis de controle de ESTADO DO BOT√ÉO
int estadoBotaoAnterior = HIGH; 
int estadoBotaoAtual = HIGH; 
bool ignoreTimeout = false; 
bool alertaLedState = false; // Estado atual do LED G4

// --- PROT√ìTIPOS DAS FUN√á√ïES ---
void blinkSinglePin3X(int pin);
void blinkDualPin3X();
void configureWakeup(); 
void setLeds(bool status, bool espera, bool alerta); 
void checkAndHandleAlerts(); // Novo: Simula a checagem de alertas

// ==============================================================================
// SETUP: Roda apenas uma vez ao ligar
// ==============================================================================
void setup() {
  Serial.begin(115200); 
  delay(1000); 
  
  // Configura√ß√£o dos Pinos
  pinMode(PINO_LED_STATUS, OUTPUT);
  pinMode(PINO_LED_ESPERA, OUTPUT);
  pinMode(PINO_LED_ALERTA, OUTPUT); 
  pinMode(PINO_BOTAO_PTT, INPUT_PULLUP); 

  configureWakeup(); 

  // Tratamento de Acordar do Sleep
  if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_EXT1) {
    currentState = STATE_IDLE;
    ignoreTimeout = true; 
    wakeUpTime = millis(); 
    Serial.println("Rob√¥ Acordou. Travando timeout por 3s.");
  } else {
    Serial.println("\n--- Rob√¥ Inicializado (Light Sleep Ativo) ---");
    currentState = STATE_IDLE;
  }
  
  setLeds(true, false, false);
  lastActivityTime = millis(); 
}


// ==============================================================================
// LOOP: O Cora√ß√£o do Rob√¥
// ==============================================================================
void loop() {
  
  // --- A. GEST√ÉO DO TEMPO DE GUARDA (GUARD TIME) ---
  if (ignoreTimeout && (millis() - wakeUpTime > GUARD_TIME)) {
    ignoreTimeout = false;
    lastActivityTime = millis(); 
    Serial.println("Timeout liberado. Timer de 50s ativo.");
  }

  // --- B. CHECAGEM DE ALERTAS (NOVO) ---
  checkAndHandleAlerts();
  
  // --- 1. LEITURA DO BOT√ÉO ---
  estadoBotaoAtual = digitalRead(PINO_BOTAO_PTT); 

  // --- 2. L√ìGICA DE DETEC√á√ÉO DE PRESSIONAMENTO (HIGH -> LOW) ---
  if (estadoBotaoAtual == LOW && estadoBotaoAnterior == HIGH) {
    tempoPressionado = millis(); 
    if (currentState != STATE_STANDBY) {
        lastActivityTime = millis(); 
    }
  }

  // --- 3. L√ìGICA DE DETEC√á√ÉO DE SOLTURA (LOW -> HIGH) ---
  else if (estadoBotaoAtual == HIGH && estadoBotaoAnterior == LOW) {
    unsigned long duracao = millis() - tempoPressionado;
    
    // A√á√ÉO: TOQUE CURTO
    if (duracao < TEMPO_TOQUE_LONGO) {
      Serial.print(">>> CLIQUE: Solto. ");

      if (currentState == STATE_STANDBY) {
        currentState = STATE_IDLE;
        blinkDualPin3X(); 
        ignoreTimeout = true; 
        wakeUpTime = millis();
        
      } else if (currentState == STATE_IDLE || currentState == STATE_ALERTA) { // Bot√£o no IDLE/ALERTA LIGA A ESCUTA
        currentState = STATE_ESPERANDO_FALA;
        blinkSinglePin3X(PINO_LED_ESPERA); 
        
      } else if (currentState == STATE_ESPERANDO_FALA) {
        // Simula√ß√£o: Ap√≥s a fala, volta para IDLE ou ALERTA
        // Manteremos IDLE aqui. Se um alerta existir, a checagem (B) muda o estado na pr√≥xima itera√ß√£o.
        currentState = STATE_IDLE; 
        blinkSinglePin3X(PINO_LED_STATUS); 
      }
      
      lastActivityTime = millis(); 
    }
    tempoPressionado = 0; 
  }

  // --- 4. L√ìGICA DE TOQUE LONGO (Shutdown Manual) ---
  if (estadoBotaoAtual == LOW && (millis() - tempoPressionado >= TEMPO_TOQUE_LONGO) && currentState != STATE_STANDBY) {
    Serial.println("A√á√ÉO: TOQUE LONGO ENCONTRADO (SHUTDOWN MANUAL)");
    blinkDualPin3X(); 
    currentState = STATE_STANDBY;
    lastActivityTime = millis(); 
    tempoPressionado = 0; 
  }
  
  // --- 5. L√ìGICA DE TIMEOUT AUTOM√ÅTICO (Economia de Energia) ---
  if (!ignoreTimeout && currentState != STATE_STANDBY && (millis() - lastActivityTime >= TIMEOUT_STANDBY)) {
    Serial.println("TIMEOUT: Entrando em STANDBY (Light Sleep).");
    currentState = STATE_STANDBY;
  }
  
  // --- 6. L√ìGICA DE CONTROLE DE ESTADO E LEDS/SUSPENS√ÉO ---
  
  if (currentState == STATE_IDLE) {
    setLeds(true, false, false); 
    
  } else if (currentState == STATE_ESPERANDO_FALA) {
    setLeds(true, true, false); 
  
  } else if (currentState == STATE_ALERTA) {
    // A l√≥gica de piscar √© tratada na fun√ß√£o checkAndHandleAlerts()
    setLeds(true, false, alertaLedState); 

  } else if (currentState == STATE_STANDBY) {
    // ESTADO CR√çTICO DE SUSPENS√ÉO
    setLeds(false, false, false); 
    
    Serial.println("Entrando em Light Sleep...");
    Serial.flush(); 
    
    configureWakeup(); 
    
    esp_light_sleep_start();
  }

  // --- 7. ATUALIZA√á√ÉO DO ESTADO ANTERIOR ---
  estadoBotaoAnterior = estadoBotaoAtual;
}


// ==============================================================================
// FUN√á√ïES DE SERVI√áO E ALERTA
// ==============================================================================

void checkAndHandleAlerts() {
  // === SIMULA√á√ÉO DE ALERTA: Mude o valor para testar ===
  bool isBatteryLow = false; 
  bool isWifiDisconnected = false;
  // Se for True, o rob√¥ estar√° em alerta
  bool isAlertConditionMet = isBatteryLow || isWifiDisconnected; 

  if (isAlertConditionMet) {
    // Se h√° um alerta, o rob√¥ deve entrar no estado de alerta
    if (currentState != STATE_ALERTA && currentState != STATE_ESPERANDO_FALA && currentState != STATE_STANDBY) {
      currentState = STATE_ALERTA;
      Serial.println("AVISO: Condi√ß√£o de Alerta Detectada. Entrando em STATE_ALERTA.");
    }

    // Apenas pisca o LED G4 se estiver no STATE_ALERTA
    if (currentState == STATE_ALERTA) {
      if (millis() - lastAlertToggle >= TEMPO_PISCADA_ALERTA) {
        alertaLedState = !alertaLedState; // Inverte o estado
        lastAlertToggle = millis();
      }
    }
  } 
  // Se o alerta foi resolvido e n√£o estamos em uma conversa, voltamos para IDLE
  else if (currentState == STATE_ALERTA) {
      currentState = STATE_IDLE;
      Serial.println("AVISO: Alerta Resolvido. Retornando a STATE_IDLE.");
  }
}

void setLeds(bool status, bool espera, bool alerta) {
  digitalWrite(PINO_LED_STATUS, status ? HIGH : LOW);
  digitalWrite(PINO_LED_ESPERA, espera ? HIGH : LOW);
  digitalWrite(PINO_LED_ALERTA, alerta ? HIGH : LOW);
}

void configureWakeup(){
  const uint64_t PTT_PIN_MASK = 1ULL << PINO_BOTAO_PTT; 
  esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_ALL); 
  esp_sleep_enable_ext1_wakeup(PTT_PIN_MASK, ESP_EXT1_WAKEUP_ALL_LOW);
}

void blinkSinglePin3X(int pin) {
  // Rotina de piscar (mantida das vers√µes anteriores)
  bool statusState = (pin == PINO_LED_STATUS) ? !digitalRead(PINO_LED_STATUS) : digitalRead(PINO_LED_STATUS);
  bool esperaState = (pin == PINO_LED_ESPERA) ? !digitalRead(PINO_LED_ESPERA) : digitalRead(PINO_LED_ESPERA);
  bool alertaState = (pin == PINO_LED_ALERTA) ? !digitalRead(PINO_LED_ALERTA) : digitalRead(PINO_LED_ALERTA);

  for (int i = 0; i < 3; i++) {
    digitalWrite(pin, HIGH);
    delay(TEMPO_PISCADA_FEEDBACK);
    digitalWrite(pin, LOW);
    delay(TEMPO_PISCADA_FEEDBACK);
  }
  
  setLeds(statusState, esperaState, alertaState);
}

void blinkDualPin3X() {
  Serial.println("Anima√ß√£o Blink 3X em Todos os LEDs.");
  for (int i = 0; i < 3; i++) {
    setLeds(true, true, true); 
    delay(TEMPO_PISCADA_FEEDBACK);
    setLeds(false, false, false); 
    delay(TEMPO_PISCADA_FEEDBACK);
  }
}

